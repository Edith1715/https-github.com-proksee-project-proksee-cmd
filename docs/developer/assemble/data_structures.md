# Proksee Assemble Data Structures

v1.0.0  
2021-02-04

The following is a high-level overview of some of the data structures used in the pipeline.

## Assembler

*assembler.py, skesa_assembler.py, spades_assembler.py*

The Assembler class is an abstract base class and, importantly, is returned as part of the AssemblyStrategy object. Functions that use the Assembler class don't need to worry about the specific assembler implemented, but rather can just invoke the .assemble() method. This should allow for easier incorporation of other assemblers in the future.

The Assembler class is currently implemented by the SpadesAssembler and SkesaAssembler classes.

## AssemblyDatabase

*assembly_database.py*

The AssemblyDatabase class serves as an object wrapper for the assembly database file. The assembly database contains statistics about assembly metrics for many different species. For example, the database contains percentile information for the N50, L50, number of contigs, and assembly length for assemblies of each species in the database. This allows us to compare an assembly produced by our pipeline with previously-derived assembly statistics.

The AssemblyDatabase class provides functions for interacting with the database file without the caller needing to worry about the specific implementation. Currently, the class loads a CSV file where assembly metrics are organized by species.

## AssemblyEvaluator

*assembly_evaluator.py, heuristic_evaluation.py, machine_learning_evaluator.py*

An abstract class used to evaluate the quality of assemblies. Currently, the AssemblyEvaluator is implemented by HeuristicEvaluator, which uses the percentile assembly statistics in the AssemblyDatabase to make evaluations, and MachineLearningEvaluator, which returns a probabilistic prediction from a machine learning strategy to make evaluations. In either case, both evaluators return an Evaluation object, which is simply a report of their evaluation.

## AssemblyMeasurer

*assembly_measurer.py*

Measures varies assemble characteristics (ex: N50, L50, number of contigs, length) using QUAST. This class produced AssemblyQuality objects.

## AssemblyQuality

*assembly_quality.py*

The AssemblyQuality object encapsulates many assembly measurements (ex: N50, L50, number of contigs, assembly length) about a single assembly into an object in order to facilitate passing information around to other functions. The fast and expert assemblies generated by our pipeline will each have a corresponding AssemblyQuality object that will each be compared to the AssemblyDatabase to see how they compare to previously-completed assembles.

This object is generated by the AssemblyMeasurer class.

## AssemblyStrategy

*assembly_strategy.py*

The AssemblyStrategy object represents a strategy to follow in order to produce an assembly. This includes whether or not to proceed with the assembly at all, a plain-language report about the strategy, and the assembler to use for assembly. The AssemblyStrategy object will contain a preconfigured Assembler object that can be used to execute the assembly.

## ContaminationHandler

*contamination_handler.py*

Identifies, filters and otherwise handles contamination in assembled contigs. In particular, this class is responsible for estimating contamination in the contigs, using MASH, and checking to see that the species estimated in individual contigs agrees with the species estimated for the entire read data set. As contamination handling is very difficult and resource intensive, this heuristic approach should help catch some of the worse cases of contamination in the assembled contig data. However, this class is currently not equiped to detect minor or medium levels of contamination.

## Evaluation

*evaluation.py, assembly_evaluation.py*

A simple, generic class representing an evaluation. It encapsulates two attributes: success (whether or not the subject was evaluated positively or negatively) and a report (a plain-language text report explaining the evaluation). This class functions as a way to return a boolean from a test / evaluation / check alongside an explanation of the result.

Evaluation is extended by AssemblyEvaluation and MachineLearningEvaluation, which contain more specific attributes for sequence assembly statistic evaluations. AssemblyEvaluation (Evaluation) and MachineLearningEvaluation (Evaluation) objects are returned by the AssemblyEvaluator, which is responsible for evaluating an assembly and reporting on the evaluation.

## ExpertSystem

*expert_system.py*

The ExpertSystem is primarily responsible for creating assembly strategies (AssemblyStrategy objects) that will be used to guide the assembly process. The ExpertSystem uses data produced throughout the pipeline in order to make decisions about how best to perform sequence assembly.

## MachineLearningAssemblyQC

*machine_learning_assembly_qc.py*

The MachineLearningAssemblyQC class loads a random forests machine learning model trained on curated NCBI assemblies. The machine learning model encapsulates feature information corresponding to species specific normalized assembly attributes (N50, number of contigs, L50, assembly length and the overall gc content) and label information corresponding to assembly inclusion or exclusion within the NCBI RefSeq database.

The MachineLearningAssemblyQC class subsequently normalizes the assembly attributes generated from AssemblyQuality class and returns the machine learning probabilistic evaluation of the assembly quality.

## NormalizedDatabase

*machine_learning_assembly_qc.py*

The NormalizedDatabase class loads a CSV file which serves as a database of species specific median (or median of log-transformed) values of different assembly attributes corresponding to N50, number of contigs, L50, assembly length and overall gc content.

The NormalizedDatabase class provides functions for interacting with the database file and compute species specific normalized assembly metrics to be used by MachineLearningAssemblyQC.

## PlatformIdentifier

*platform_identify.py*

The PlatformIdentifier class attempts to identify the sequencing platform that was used to sequence the reads. This is accomplished by looking at the FASTQ file encoding and seeing if any of the information can be used to uniquely identify a sequencing platform. However, this process is not always successful and sometimes the platform will be determined to be "Unidentifiable".

## ReadFilterer

*read_filterer.py*

Filters the reads using FASTP. The ReadFilterer object encapsulates information about the input reads and the several output files created by running FASTP.

## ReadQuality

*read_quality.py*

The ReadQuality object encapsulates information about the quality of reads. It includes measures such as the number of reads, the rate of Q30 or higher bases, and the GC-content.

## Reads

*reads.py*

Encapsulates sequencing reads into a single object. This simplifies the need to pass forward and, optionally, reverse reads and accommodates a future possibility of having more than two read files.

## Species

*species.py*

Represents a biological species. The name attribute should exactly match the scientific name for the species (including capitalization). The confidence attribute relates to the confidence of the species assignment, which may be derived from species estimation tools, such as MASH.

## SpeciesEstimation

*species_estimation.py*

Encapsulates a single "estimation" of a species. In particular, it is designed to encapsulate an estimation from RefSeq Masher into a single object that can be passed and operated on more easily.

## SpeciesEstimator

*species_estimator.py*

The SpeciesEstimator represents a tool used to estimate species from either sequencing reads or contigs. It is not designed to be a species classifier, but rather simply estimate the species, based on the information on hand (in particular, the RefSeq Masher database).
