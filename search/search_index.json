{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Proksee Proksee is a suite of command line tools for performing genome assembly , evaluation , annotation, and visualization of microbial genomes. Proksee is developed as a collaboration between the Public Health Agency of Canada, the University of Manitoba, and the University of Alberta. This resource provides information about the assembly and evaluation components of Proksee, whereas information about the annotation and visualization components may be found at https://beta.proksee.ca/ . Release v1.0.0-alpha This is the initial public release of Proksee. This release focuses on Proksee Assemble, the sequence assembly component of Proksee. Contact Eric Enns : eric.enns@canada.ca","title":"Home"},{"location":"#proksee","text":"Proksee is a suite of command line tools for performing genome assembly , evaluation , annotation, and visualization of microbial genomes. Proksee is developed as a collaboration between the Public Health Agency of Canada, the University of Manitoba, and the University of Alberta. This resource provides information about the assembly and evaluation components of Proksee, whereas information about the annotation and visualization components may be found at https://beta.proksee.ca/ .","title":"Proksee"},{"location":"#release","text":"v1.0.0-alpha This is the initial public release of Proksee. This release focuses on Proksee Assemble, the sequence assembly component of Proksee.","title":"Release"},{"location":"#contact","text":"Eric Enns : eric.enns@canada.ca","title":"Contact"},{"location":"installation/","text":"Installation Proksee requires that the following software packages be installed: Python 3.7 Pip fastp Mash Skesa Quast Scipy Spades The simplest way to install these packages, and any other related dependencies, is by installing them into a conda environment, using the provided installation script as follows: conda env create -f environment.yml conda activate proksee You can then confirm that Proksee is installed with the following command, which should show a help message: proksee --help","title":"Installation"},{"location":"installation/#installation","text":"Proksee requires that the following software packages be installed: Python 3.7 Pip fastp Mash Skesa Quast Scipy Spades The simplest way to install these packages, and any other related dependencies, is by installing them into a conda environment, using the provided installation script as follows: conda env create -f environment.yml conda activate proksee You can then confirm that Proksee is installed with the following command, which should show a help message: proksee --help","title":"Installation"},{"location":"developer/json/","text":"Assembly Information JSON File When Proksee assemble completes, a JSON-formatted file describing information about the reads, quality, and assembly is written. The intention of this file is to make the standard output of Proksee Assemble more easily machine-readable, for other applications that use assemblies generated by Proksee Assemble. The assembly information JSON file is named \"assembly_info.json\". Please find below an overview of the format and an example output file. JSON File Format Specification { \"Technology\": <STRING: The sequencing technology.>, \"Species\": <STRING: The estimated species.>, \"Read Quality\": { \"Total Reads\": <INT: The total number of reads.>, \"Total Bases\": <INT: The total number of bases in all reads.>, \"Q20 Bases\": <INT: The total number of bases in all reads with quality score 20 or higher.>, \"Q20 Rate\": <FLOAT: The rate of Q20 bases; what fraction of all bases are at least Q20.>, \"Q30 Bases\": <INT: The total number of bases in all reads with quality score 30 or higher.>, \"Q30 Rate\": <FLOAT: The rate of Q30 bases; what fraction of all bases are at least Q30.>, \"GC Content\": <FLOAT: The GC-content of the reads. Between 0 and 1.> }, \"Assembly Quality\": { \"N50\": <INT: The N50 of the expert assembly.>, \"L50\": <INT: The L50 of the expert assembly.>, \"Number of Contigs\": <INT: The number of contigs in the expert assembly.>, \"Assembly Size\": <INT: The assembly size of the expert assembly.> }, \"Heuristic Evaluation\": { \"Success\": <BOOL: Whether or not the expert assembly passed a heuristic evaluation.>, \"N50 Pass\": <BOOL: Whether or not the N50 of the expert assembly passed a heuristic evaluation.>, \"N50 Report\": <STRING: A report on the N50 of the expert assembly.>, \"Contigs Pass\": <BOOL: Whether or not the number of contigs in the expert assembly passed a heuristic evaluation.>, \"Contigs Report\": <STRING: A report on the number of contigs in the expert assembly.>, \"L50 Pass\": <BOOL: Whether or not the L50 of the expert assembly passed a heuristic evaluation.>, \"L50 Report\": <STRING: A report on the L50 of the expert assembly.>, \"Length Pass\": <BOOL: Whether or not the assembly length of the expert assembly passed a heuristic evaluation.>, \"Length Report\": <STRING: A report on the length of the expert assembly.> }, \"Machine Learning Evaluation\": { \"Success\": <BOOL: Whether or not the expert assembly was evaluated as a success by the machine learning algorithm.>, \"Probability\": <FLOAT: The probability of the expert assembly being a \"good\" assembly.>, \"Report\": <STRING: A report on the machine learning evaluation of the expert assembly.> } } Example JSON File { \"Technology\": \"Unidentifiable\", \"Species\": \"Unknown\", \"Read Quality\": { \"Total Reads\": 352355, \"Total Bases\": 35587855, \"Q20 Bases\": 22752475, \"Q20 Rate\": 0.6393325756778542, \"Q30 Bases\": 18288469, \"Q30 Rate\": 0.5138963559337869, \"GC Content\": 0.299302 }, \"Assembly Quality\": { \"N50\": 2824, \"L50\": 298, \"Number of Contigs\": 1323, \"Assembly Size\": 2703272 }, \"Heuristic Evaluation\": { \"Success\": false, \"N50 Pass\": false, \"N50 Report\": \"FAIL: The N50 is smaller than expected: 2824\\n The N50 lower bound is: 5000\\n\", \"Contigs Pass\": true, \"Contigs Report\": \"PASS: The number of contigs is acceptable: 1323\\n The number of contigs lower bound is: 5000\\n\", \"L50 Pass\": true, \"L50 Report\": \"PASS: The L50 is acceptable: 298\\n The L50 upper bound is: 500\\n\", \"Length Pass\": true, \"Length Report\": \"PASS: The length is acceptable: 2703272\\n The length lower bound is: 5000\\n\" }, \"Machine Learning Evaluation\": { \"Success\": false, \"Probability\": 0.0, \"Report\": \"The species is not present in the database.\" } }","title":"JSON File Output"},{"location":"developer/json/#assembly-information-json-file","text":"When Proksee assemble completes, a JSON-formatted file describing information about the reads, quality, and assembly is written. The intention of this file is to make the standard output of Proksee Assemble more easily machine-readable, for other applications that use assemblies generated by Proksee Assemble. The assembly information JSON file is named \"assembly_info.json\". Please find below an overview of the format and an example output file. JSON File Format Specification { \"Technology\": <STRING: The sequencing technology.>, \"Species\": <STRING: The estimated species.>, \"Read Quality\": { \"Total Reads\": <INT: The total number of reads.>, \"Total Bases\": <INT: The total number of bases in all reads.>, \"Q20 Bases\": <INT: The total number of bases in all reads with quality score 20 or higher.>, \"Q20 Rate\": <FLOAT: The rate of Q20 bases; what fraction of all bases are at least Q20.>, \"Q30 Bases\": <INT: The total number of bases in all reads with quality score 30 or higher.>, \"Q30 Rate\": <FLOAT: The rate of Q30 bases; what fraction of all bases are at least Q30.>, \"GC Content\": <FLOAT: The GC-content of the reads. Between 0 and 1.> }, \"Assembly Quality\": { \"N50\": <INT: The N50 of the expert assembly.>, \"L50\": <INT: The L50 of the expert assembly.>, \"Number of Contigs\": <INT: The number of contigs in the expert assembly.>, \"Assembly Size\": <INT: The assembly size of the expert assembly.> }, \"Heuristic Evaluation\": { \"Success\": <BOOL: Whether or not the expert assembly passed a heuristic evaluation.>, \"N50 Pass\": <BOOL: Whether or not the N50 of the expert assembly passed a heuristic evaluation.>, \"N50 Report\": <STRING: A report on the N50 of the expert assembly.>, \"Contigs Pass\": <BOOL: Whether or not the number of contigs in the expert assembly passed a heuristic evaluation.>, \"Contigs Report\": <STRING: A report on the number of contigs in the expert assembly.>, \"L50 Pass\": <BOOL: Whether or not the L50 of the expert assembly passed a heuristic evaluation.>, \"L50 Report\": <STRING: A report on the L50 of the expert assembly.>, \"Length Pass\": <BOOL: Whether or not the assembly length of the expert assembly passed a heuristic evaluation.>, \"Length Report\": <STRING: A report on the length of the expert assembly.> }, \"Machine Learning Evaluation\": { \"Success\": <BOOL: Whether or not the expert assembly was evaluated as a success by the machine learning algorithm.>, \"Probability\": <FLOAT: The probability of the expert assembly being a \"good\" assembly.>, \"Report\": <STRING: A report on the machine learning evaluation of the expert assembly.> } } Example JSON File { \"Technology\": \"Unidentifiable\", \"Species\": \"Unknown\", \"Read Quality\": { \"Total Reads\": 352355, \"Total Bases\": 35587855, \"Q20 Bases\": 22752475, \"Q20 Rate\": 0.6393325756778542, \"Q30 Bases\": 18288469, \"Q30 Rate\": 0.5138963559337869, \"GC Content\": 0.299302 }, \"Assembly Quality\": { \"N50\": 2824, \"L50\": 298, \"Number of Contigs\": 1323, \"Assembly Size\": 2703272 }, \"Heuristic Evaluation\": { \"Success\": false, \"N50 Pass\": false, \"N50 Report\": \"FAIL: The N50 is smaller than expected: 2824\\n The N50 lower bound is: 5000\\n\", \"Contigs Pass\": true, \"Contigs Report\": \"PASS: The number of contigs is acceptable: 1323\\n The number of contigs lower bound is: 5000\\n\", \"L50 Pass\": true, \"L50 Report\": \"PASS: The L50 is acceptable: 298\\n The L50 upper bound is: 500\\n\", \"Length Pass\": true, \"Length Report\": \"PASS: The length is acceptable: 2703272\\n The length lower bound is: 5000\\n\" }, \"Machine Learning Evaluation\": { \"Success\": false, \"Probability\": 0.0, \"Report\": \"The species is not present in the database.\" } }","title":"Assembly Information JSON File"},{"location":"developer/overview/","text":"Developer Overview for Proksee v1.0.0-alpha 2021-04-08 Proksee is a Python 3 software project that provides a computational pipeline for performing sequence assembly, annotation, and visualization of microbial genomes. It is intented to be used by researchers who will have expertise in microbial genomics, but not necessarily bioinformatics or computational biology. Proksee is implemented using object orientation priciples. It is comprised of multiple commands that that can be run individually or together in a larger computational pipeline. The complete Proksee pipeline would involve sequence assembly using proksee assemble and then sequence annotation and visualization using Proksee's web interface . File Organization Proksee directories are organized as follows: docs : user and developer documentation docs/developer : developer documentation proksee : source files tests : test files In addition, the following are notable files: CHANGELOG : log of notable changes made to the project environment.yml : programmatic instructions for installing a Proksee conda environment LICENSE : legal license for the project MANIFEST.in : non-source files to include in package installation README.md : short documentation targetted towards users setup.py : programmatic instructions for package installation tox.ini : programmatic instructions for running tox Commands Proksee is comprised of the following commands: assemble evaluate These commands are implemented using the Click Python package . The entry point of the program is proksee/cli.py , which in turn calls the individual commands located in the proksee/commands directory. Commands are invoked on the command line by entering the name of the program, proksee, followed by the name of the command being invoked. For example: proksee assemble proksee evaluate","title":"Overview"},{"location":"developer/overview/#developer-overview-for-proksee","text":"v1.0.0-alpha 2021-04-08 Proksee is a Python 3 software project that provides a computational pipeline for performing sequence assembly, annotation, and visualization of microbial genomes. It is intented to be used by researchers who will have expertise in microbial genomics, but not necessarily bioinformatics or computational biology. Proksee is implemented using object orientation priciples. It is comprised of multiple commands that that can be run individually or together in a larger computational pipeline. The complete Proksee pipeline would involve sequence assembly using proksee assemble and then sequence annotation and visualization using Proksee's web interface .","title":"Developer Overview for Proksee"},{"location":"developer/overview/#file-organization","text":"Proksee directories are organized as follows: docs : user and developer documentation docs/developer : developer documentation proksee : source files tests : test files In addition, the following are notable files: CHANGELOG : log of notable changes made to the project environment.yml : programmatic instructions for installing a Proksee conda environment LICENSE : legal license for the project MANIFEST.in : non-source files to include in package installation README.md : short documentation targetted towards users setup.py : programmatic instructions for package installation tox.ini : programmatic instructions for running tox","title":"File Organization"},{"location":"developer/overview/#commands","text":"Proksee is comprised of the following commands: assemble evaluate These commands are implemented using the Click Python package . The entry point of the program is proksee/cli.py , which in turn calls the individual commands located in the proksee/commands directory. Commands are invoked on the command line by entering the name of the program, proksee, followed by the name of the command being invoked. For example: proksee assemble proksee evaluate","title":"Commands"},{"location":"developer/assemble/assemble/","text":"Proksee Assemble Overview v1.0.0-alpha 2021-02-04 The assemble command is responsible for assembling sequencing reads into contigs. It uses an expert system to guide decision-making through the various stages of assembly. Pipeline The assemble pipeline consists of three major stages: Stage 1: Pre-Assembly : Attempts to estimate information about the reads and prepares the reads for sequence assembly. Stage 2: Fast Assembly : Assembles the quickly in order to produce a draft assemble that will help inform the expert assembly. Stage 3: Expert Assembly : Assembles the reads in an expert manner using information gathered during the previous stages. Stage 1: Pre-Assembly The pre-assembly stage is responsible for estimating information about the reads, including the species and sequencing technology, and preparing the reads for sequence assembly. Validate Inputs The forward and reverse read inputs are validated in order to ensure that they are in FASTQ format. The pipeline will terminate if the inputs appear to be formatted incorrectly. Identify Sequencing Platform The sequencing platform is estimated by looking at the encoding of the FASTQ-formatted input reads. If there is not enough information to estimate the sequencing platform, then the platform will be unidentifiable, but assembly will continue. This stage is skipped if the user provides the sequencing platform as a command-line argument. Filter Reads The reads are filtered in order to remove low-quality sequencing content and improve the assembly. FASTP is used to filter the reads. Determine Read Quality The read quality is determined from the filtered reads by parsing the output of FASTP in the previous step. Since FASTP provides some quality metrics of the reads after filtering, this information is parsed into the pipeline and used in later steps. Estimate Species Attempts to estimate the species using MASH. Since MASH is not designed to be a classifier, we shouldn't say that the species is classified , but rather the species is estimated from k -mer information in the reads. MASH output can be messy on real-world data and will often report multiple species present. High thresholds are therefore used in order to only report species that are very likely to be present. As a consequence of this approach, we cannot confidently make claims about low levels of contamination in the reads and thus ignore such contamination. Stage 2: Fast Assembly The fast assembly stage assembles the reads hastily in order to gather some approximate structural information that can be seen after assembling reads into contigs. It should provide the pipeline with more accurate information about which major species are present, approximately how large the assembly will be, and if there is any major contamination present. Create Strategy Creates a fast assembly strategy using the information gathered during the pre-assembly stage. The sequencing platform, estimated species, and read quality are provided to the expert system, which creates a fast assembly strategy using this information. It is possible that the expert system will decide that the best course of action is to terminate the pipeline because the provided information suggests no good assembly can be produced. This might happen if the read quality after filtering remains too low, or if there are too many major species present in the reads, suggesting major contamination. Assemble Assembles the reads by executing the fast assembly strategy. Currently, this will always involve using the SKESA assembler. However, it is possible to expand to other assemblers in the future. Evaluate Contamination Evaluates possible contamination in the assembled reads. This is achieved using MASH to ensure that the five largest assembled contigs are estimated to have the same major species as the initial species estimation in the pre-assembly stage. The choice of five contigs is arbitrary, but as MASH requires a complete \"restart\" for every contig indeptendently evaluated, the number of contigs checked greatly increases the time required to complete this stage. The evaluation contamination step will not identify minor or medium levels of contamination, but should identify some major levels of species contamination in the contigs. The pipeline will terminate if there is a disagreement in the species estimations. Evaluate Assembly Evaluates the assembly using QUAST and an independent machine learning algorithm. For QUAST evaluation, the pipeline uses a non-reference-based QUAST analysis, because of the difficulty of selecting a reference correctly and complication of needing to maintain either a database of references or the ability to download references on the fly. Several assembly metrics are collected, including N50, number of contigs, L50, and total assembly size. For machine learning evaluation, the pipeline returns the prediction probability of the assembly resembling the quality of RefSeq-included NCBI Reference Sequences. The prediction probability is computed from a random forests machine learning model trained on curated NCBI assemblies with intra-species normalized assembly metrics including N50, number of contigs, L50, total assembly size and the overall gc content. The probability ranges between 0 and 1, with 1 being the highest probability of an assembly resembling a RefSeq-included NCBI Reference Sequence. Stage 3: Expert Assembly The expert assembly stage uses information collected in the pre-assembly and fast assembly stages to create an expert strategy for assembling the reads. The assembly generated in this stage should be of higher quality than the assembly created in the fast assembly stage. Create Strategy Creates a strategy using the expert system by analyzing the assembly metrics of the fast assembly (N50, L50, number of contigs, assembly length). The fast assembly metrics are compared against the sequence assembly database to see if the assembly metrics agree with what would be expect for the species. If these assembly metrics are in major disagreement with what would be expected for the species, then the pipeline is terminated. Otherwise, an expert assembly strategy is created and the pipeline proceeds. Assemble Assembles the reads by executing the expert assembly strategy. Currently, this will always involve using SPAdes. However, it is possible to expand assembly to other assemblers in the future. Evaluate Assembly Evaluates the assembly using QUAST and machine learning probabilistic evaluation, in the same manner as previously done in the fast assembly stage. The QUAST analysis is done without a reference, because of the difficulties of regularly selecting a good reference and maintaining a high-quality reference database. Compare Assemblies Compares the assembly metrics of all assemblies run in the pipeline (fast, expert) and reports them. These assembly metrics include N50, L50, number of contigs, and assembly length.","title":"Assemble"},{"location":"developer/assemble/assemble/#proksee-assemble-overview","text":"v1.0.0-alpha 2021-02-04 The assemble command is responsible for assembling sequencing reads into contigs. It uses an expert system to guide decision-making through the various stages of assembly.","title":"Proksee Assemble Overview"},{"location":"developer/assemble/assemble/#pipeline","text":"The assemble pipeline consists of three major stages: Stage 1: Pre-Assembly : Attempts to estimate information about the reads and prepares the reads for sequence assembly. Stage 2: Fast Assembly : Assembles the quickly in order to produce a draft assemble that will help inform the expert assembly. Stage 3: Expert Assembly : Assembles the reads in an expert manner using information gathered during the previous stages.","title":"Pipeline"},{"location":"developer/assemble/assemble/#stage-1-pre-assembly","text":"The pre-assembly stage is responsible for estimating information about the reads, including the species and sequencing technology, and preparing the reads for sequence assembly.","title":"Stage 1: Pre-Assembly"},{"location":"developer/assemble/assemble/#validate-inputs","text":"The forward and reverse read inputs are validated in order to ensure that they are in FASTQ format. The pipeline will terminate if the inputs appear to be formatted incorrectly.","title":"Validate Inputs"},{"location":"developer/assemble/assemble/#identify-sequencing-platform","text":"The sequencing platform is estimated by looking at the encoding of the FASTQ-formatted input reads. If there is not enough information to estimate the sequencing platform, then the platform will be unidentifiable, but assembly will continue. This stage is skipped if the user provides the sequencing platform as a command-line argument.","title":"Identify Sequencing Platform"},{"location":"developer/assemble/assemble/#filter-reads","text":"The reads are filtered in order to remove low-quality sequencing content and improve the assembly. FASTP is used to filter the reads.","title":"Filter Reads"},{"location":"developer/assemble/assemble/#determine-read-quality","text":"The read quality is determined from the filtered reads by parsing the output of FASTP in the previous step. Since FASTP provides some quality metrics of the reads after filtering, this information is parsed into the pipeline and used in later steps.","title":"Determine Read Quality"},{"location":"developer/assemble/assemble/#estimate-species","text":"Attempts to estimate the species using MASH. Since MASH is not designed to be a classifier, we shouldn't say that the species is classified , but rather the species is estimated from k -mer information in the reads. MASH output can be messy on real-world data and will often report multiple species present. High thresholds are therefore used in order to only report species that are very likely to be present. As a consequence of this approach, we cannot confidently make claims about low levels of contamination in the reads and thus ignore such contamination.","title":"Estimate Species"},{"location":"developer/assemble/assemble/#stage-2-fast-assembly","text":"The fast assembly stage assembles the reads hastily in order to gather some approximate structural information that can be seen after assembling reads into contigs. It should provide the pipeline with more accurate information about which major species are present, approximately how large the assembly will be, and if there is any major contamination present.","title":"Stage 2: Fast Assembly"},{"location":"developer/assemble/assemble/#create-strategy","text":"Creates a fast assembly strategy using the information gathered during the pre-assembly stage. The sequencing platform, estimated species, and read quality are provided to the expert system, which creates a fast assembly strategy using this information. It is possible that the expert system will decide that the best course of action is to terminate the pipeline because the provided information suggests no good assembly can be produced. This might happen if the read quality after filtering remains too low, or if there are too many major species present in the reads, suggesting major contamination.","title":"Create Strategy"},{"location":"developer/assemble/assemble/#assemble","text":"Assembles the reads by executing the fast assembly strategy. Currently, this will always involve using the SKESA assembler. However, it is possible to expand to other assemblers in the future.","title":"Assemble"},{"location":"developer/assemble/assemble/#evaluate-contamination","text":"Evaluates possible contamination in the assembled reads. This is achieved using MASH to ensure that the five largest assembled contigs are estimated to have the same major species as the initial species estimation in the pre-assembly stage. The choice of five contigs is arbitrary, but as MASH requires a complete \"restart\" for every contig indeptendently evaluated, the number of contigs checked greatly increases the time required to complete this stage. The evaluation contamination step will not identify minor or medium levels of contamination, but should identify some major levels of species contamination in the contigs. The pipeline will terminate if there is a disagreement in the species estimations.","title":"Evaluate Contamination"},{"location":"developer/assemble/assemble/#evaluate-assembly","text":"Evaluates the assembly using QUAST and an independent machine learning algorithm. For QUAST evaluation, the pipeline uses a non-reference-based QUAST analysis, because of the difficulty of selecting a reference correctly and complication of needing to maintain either a database of references or the ability to download references on the fly. Several assembly metrics are collected, including N50, number of contigs, L50, and total assembly size. For machine learning evaluation, the pipeline returns the prediction probability of the assembly resembling the quality of RefSeq-included NCBI Reference Sequences. The prediction probability is computed from a random forests machine learning model trained on curated NCBI assemblies with intra-species normalized assembly metrics including N50, number of contigs, L50, total assembly size and the overall gc content. The probability ranges between 0 and 1, with 1 being the highest probability of an assembly resembling a RefSeq-included NCBI Reference Sequence.","title":"Evaluate Assembly"},{"location":"developer/assemble/assemble/#stage-3-expert-assembly","text":"The expert assembly stage uses information collected in the pre-assembly and fast assembly stages to create an expert strategy for assembling the reads. The assembly generated in this stage should be of higher quality than the assembly created in the fast assembly stage.","title":"Stage 3: Expert Assembly"},{"location":"developer/assemble/assemble/#create-strategy_1","text":"Creates a strategy using the expert system by analyzing the assembly metrics of the fast assembly (N50, L50, number of contigs, assembly length). The fast assembly metrics are compared against the sequence assembly database to see if the assembly metrics agree with what would be expect for the species. If these assembly metrics are in major disagreement with what would be expected for the species, then the pipeline is terminated. Otherwise, an expert assembly strategy is created and the pipeline proceeds.","title":"Create Strategy"},{"location":"developer/assemble/assemble/#assemble_1","text":"Assembles the reads by executing the expert assembly strategy. Currently, this will always involve using SPAdes. However, it is possible to expand assembly to other assemblers in the future.","title":"Assemble"},{"location":"developer/assemble/assemble/#evaluate-assembly_1","text":"Evaluates the assembly using QUAST and machine learning probabilistic evaluation, in the same manner as previously done in the fast assembly stage. The QUAST analysis is done without a reference, because of the difficulties of regularly selecting a good reference and maintaining a high-quality reference database.","title":"Evaluate Assembly"},{"location":"developer/assemble/assemble/#compare-assemblies","text":"Compares the assembly metrics of all assemblies run in the pipeline (fast, expert) and reports them. These assembly metrics include N50, L50, number of contigs, and assembly length.","title":"Compare Assemblies"},{"location":"developer/assemble/data_structures/","text":"Proksee Assemble Data Structures v1.0.0-alpha 2021-02-04 The following is a high-level overview of some of the data structures used in the pipeline. Assembler assembler.py, skesa_assembler.py, spades_assembler.py The Assembler class is an abstract base class and, importantly, is returned as part of the AssemblyStrategy object. Functions that use the Assembler class don't need to worry about the specific assembler implemented, but rather can just invoke the .assemble() method. This should allow for easier incorporation of other assemblers in the future. The Assembler class is currently implemented by the SpadesAssembler and SkesaAssembler classes. AssemblyDatabase assembly_database.py The AssemblyDatabase class serves as an object wrapper for the assembly database file. The assembly database contains statistics about assembly metrics for many different species. For example, the database contains percentile information for the N50, L50, number of contigs, and assembly length for assemblies of each species in the database. This allows us to compare an assembly produced by our pipeline with previously-derived assembly statistics. The AssemblyDatabase class provides functions for interacting with the database file without the caller needing to worry about the specific implementation. Currently, the class loads a CSV file where assembly metrics are organized by species. AssemblyEvaluator assembly_evaluator.py, heuristic_evaluation.py, machine_learning_evaluator.py An abstract class used to evaluate the quality of assemblies. Currently, the AssemblyEvaluator is implemented by HeuristicEvaluator, which uses the percentile assembly statistics in the AssemblyDatabase to make evaluations, and MachineLearningEvaluator, which returns a probabilistic prediction from a machine learning strategy to make evaluations. In either case, both evaluators return an Evaluation object, which is simply a report of their evaluation. AssemblyMeasurer assembly_measurer.py Measures varies assemble characteristics (ex: N50, L50, number of contigs, length) using QUAST. This class produced AssemblyQuality objects. AssemblyQuality assembly_quality.py The AssemblyQuality object encapsulates many assembly measurements (ex: N50, L50, number of contigs, assembly length) about a single assembly into an object in order to facilitate passing information around to other functions. The fast and expert assemblies generated by our pipeline will each have a corresponding AssemblyQuality object that will each be compared to the AssemblyDatabase to see how they compare to previously-completed assembles. This object is generated by the AssemblyMeasurer class. AssemblyStrategy assembly_strategy.py The AssemblyStrategy object represents a strategy to follow in order to produce an assembly. This includes whether or not to proceed with the assembly at all, a plain-language report about the strategy, and the assembler to use for assembly. The AssemblyStrategy object will contain a preconfigured Assembler object that can be used to execute the assembly. ContaminationHandler contamination_handler.py Identifies, filters and otherwise handles contamination in assembled contigs. In particular, this class is responsible for estimating contamination in the contigs, using MASH, and checking to see that the species estimated in individual contigs agrees with the species estimated for the entire read data set. As contamination handling is very difficult and resource intensive, this heuristic approach should help catch some of the worse cases of contamination in the assembled contig data. However, this class is currently not equiped to detect minor or medium levels of contamination. Evaluation evaluation.py, assembly_evaluation.py A simple, generic class representing an evaluation. It encapsulates two attributes: success (whether or not the subject was evaluated positively or negatively) and a report (a plain-language text report explaining the evaluation). This class functions as a way to return a boolean from a test / evaluation / check alongside an explanation of the result. Evaluation is extended by AssemblyEvaluation and MachineLearningEvaluation, which contain more specific attributes for sequence assembly statistic evaluations. AssemblyEvaluation (Evaluation) and MachineLearningEvaluation (Evaluation) objects are returned by the AssemblyEvaluator, which is responsible for evaluating an assembly and reporting on the evaluation. ExpertSystem expert_system.py The ExpertSystem is primarily responsible for creating assembly strategies (AssemblyStrategy objects) that will be used to guide the assembly process. The ExpertSystem uses data produced throughout the pipeline in order to make decisions about how best to perform sequence assembly. MachineLearningAssemblyQC machine_learning_assembly_qc.py The MachineLearningAssemblyQC class loads a random forests machine learning model trained on curated NCBI assemblies. The machine learning model encapsulates feature information corresponding to species specific normalized assembly attributes (N50, number of contigs, L50, assembly length and the overall gc content) and label information corresponding to assembly inclusion or exclusion within the NCBI RefSeq database. The MachineLearningAssemblyQC class subsequently processes the data of a new/input assembly, by normalizing the assembly attributes generated from AssemblyQuality class and returning the machine learning probabilistic evaluation of the assembly. NormalizedDatabase machine_learning_assembly_qc.py The NormalizedDatabase class loads a CSV file which serves as a database of species specific median (or median of log-transformed) values of different assembly attributes corresponding to N50, number of contigs, L50, assembly length and overall gc content. The NormalizedDatabase class provides functions for interacting with the database file and compute species specific normalized assembly metrics to be used by MachineLearningAssemblyQC. PlatformIdentifier platform_identify.py The PlatformIdentifier class attempts to identify the sequencing platform that was used to sequence the reads. This is accomplished by looking at the FASTQ file encoding and seeing if any of the information can be used to uniquely identify a sequencing platform. However, this process is not always successful and sometimes the platform will be determined to be \"Unidentifiable\". ReadFilterer read_filterer.py Filters the reads using FASTP. The ReadFilterer object encapsulates information about the input reads and the several output files created by running FASTP. ReadQuality read_quality.py The ReadQuality object encapsulates information about the quality of reads. It includes measures such as the number of reads, the rate of Q30 or higher bases, and the GC-content. Reads reads.py Encapsulates sequencing reads into a single object. This simplifies the need to pass forward and, optionally, reverse reads and accommodates a future possibility of having more than two read files. Species species.py Represents a biological species. The name attribute should exactly match the scientific name for the species (including capitalization). The confidence attribute relates to the confidence of the species assignment, which may be derived from species estimation tools, such as MASH. SpeciesEstimation species_estimation.py Encapsulates a single \"estimation\" of a species. In particular, it is designed to encapsulate an estimation from Mash into a single object that can be passed and operated on more easily. SpeciesEstimator species_estimator.py The SpeciesEstimator represents a tool used to estimate species from either sequencing reads or contigs. It is not designed to be a species classifier, but rather simply estimate the species, based on the information on hand (in particular, the RefSeq Masher database).","title":"Data Structures"},{"location":"developer/assemble/data_structures/#proksee-assemble-data-structures","text":"v1.0.0-alpha 2021-02-04 The following is a high-level overview of some of the data structures used in the pipeline.","title":"Proksee Assemble Data Structures"},{"location":"developer/assemble/data_structures/#assembler","text":"assembler.py, skesa_assembler.py, spades_assembler.py The Assembler class is an abstract base class and, importantly, is returned as part of the AssemblyStrategy object. Functions that use the Assembler class don't need to worry about the specific assembler implemented, but rather can just invoke the .assemble() method. This should allow for easier incorporation of other assemblers in the future. The Assembler class is currently implemented by the SpadesAssembler and SkesaAssembler classes.","title":"Assembler"},{"location":"developer/assemble/data_structures/#assemblydatabase","text":"assembly_database.py The AssemblyDatabase class serves as an object wrapper for the assembly database file. The assembly database contains statistics about assembly metrics for many different species. For example, the database contains percentile information for the N50, L50, number of contigs, and assembly length for assemblies of each species in the database. This allows us to compare an assembly produced by our pipeline with previously-derived assembly statistics. The AssemblyDatabase class provides functions for interacting with the database file without the caller needing to worry about the specific implementation. Currently, the class loads a CSV file where assembly metrics are organized by species.","title":"AssemblyDatabase"},{"location":"developer/assemble/data_structures/#assemblyevaluator","text":"assembly_evaluator.py, heuristic_evaluation.py, machine_learning_evaluator.py An abstract class used to evaluate the quality of assemblies. Currently, the AssemblyEvaluator is implemented by HeuristicEvaluator, which uses the percentile assembly statistics in the AssemblyDatabase to make evaluations, and MachineLearningEvaluator, which returns a probabilistic prediction from a machine learning strategy to make evaluations. In either case, both evaluators return an Evaluation object, which is simply a report of their evaluation.","title":"AssemblyEvaluator"},{"location":"developer/assemble/data_structures/#assemblymeasurer","text":"assembly_measurer.py Measures varies assemble characteristics (ex: N50, L50, number of contigs, length) using QUAST. This class produced AssemblyQuality objects.","title":"AssemblyMeasurer"},{"location":"developer/assemble/data_structures/#assemblyquality","text":"assembly_quality.py The AssemblyQuality object encapsulates many assembly measurements (ex: N50, L50, number of contigs, assembly length) about a single assembly into an object in order to facilitate passing information around to other functions. The fast and expert assemblies generated by our pipeline will each have a corresponding AssemblyQuality object that will each be compared to the AssemblyDatabase to see how they compare to previously-completed assembles. This object is generated by the AssemblyMeasurer class.","title":"AssemblyQuality"},{"location":"developer/assemble/data_structures/#assemblystrategy","text":"assembly_strategy.py The AssemblyStrategy object represents a strategy to follow in order to produce an assembly. This includes whether or not to proceed with the assembly at all, a plain-language report about the strategy, and the assembler to use for assembly. The AssemblyStrategy object will contain a preconfigured Assembler object that can be used to execute the assembly.","title":"AssemblyStrategy"},{"location":"developer/assemble/data_structures/#contaminationhandler","text":"contamination_handler.py Identifies, filters and otherwise handles contamination in assembled contigs. In particular, this class is responsible for estimating contamination in the contigs, using MASH, and checking to see that the species estimated in individual contigs agrees with the species estimated for the entire read data set. As contamination handling is very difficult and resource intensive, this heuristic approach should help catch some of the worse cases of contamination in the assembled contig data. However, this class is currently not equiped to detect minor or medium levels of contamination.","title":"ContaminationHandler"},{"location":"developer/assemble/data_structures/#evaluation","text":"evaluation.py, assembly_evaluation.py A simple, generic class representing an evaluation. It encapsulates two attributes: success (whether or not the subject was evaluated positively or negatively) and a report (a plain-language text report explaining the evaluation). This class functions as a way to return a boolean from a test / evaluation / check alongside an explanation of the result. Evaluation is extended by AssemblyEvaluation and MachineLearningEvaluation, which contain more specific attributes for sequence assembly statistic evaluations. AssemblyEvaluation (Evaluation) and MachineLearningEvaluation (Evaluation) objects are returned by the AssemblyEvaluator, which is responsible for evaluating an assembly and reporting on the evaluation.","title":"Evaluation"},{"location":"developer/assemble/data_structures/#expertsystem","text":"expert_system.py The ExpertSystem is primarily responsible for creating assembly strategies (AssemblyStrategy objects) that will be used to guide the assembly process. The ExpertSystem uses data produced throughout the pipeline in order to make decisions about how best to perform sequence assembly.","title":"ExpertSystem"},{"location":"developer/assemble/data_structures/#machinelearningassemblyqc","text":"machine_learning_assembly_qc.py The MachineLearningAssemblyQC class loads a random forests machine learning model trained on curated NCBI assemblies. The machine learning model encapsulates feature information corresponding to species specific normalized assembly attributes (N50, number of contigs, L50, assembly length and the overall gc content) and label information corresponding to assembly inclusion or exclusion within the NCBI RefSeq database. The MachineLearningAssemblyQC class subsequently processes the data of a new/input assembly, by normalizing the assembly attributes generated from AssemblyQuality class and returning the machine learning probabilistic evaluation of the assembly.","title":"MachineLearningAssemblyQC"},{"location":"developer/assemble/data_structures/#normalizeddatabase","text":"machine_learning_assembly_qc.py The NormalizedDatabase class loads a CSV file which serves as a database of species specific median (or median of log-transformed) values of different assembly attributes corresponding to N50, number of contigs, L50, assembly length and overall gc content. The NormalizedDatabase class provides functions for interacting with the database file and compute species specific normalized assembly metrics to be used by MachineLearningAssemblyQC.","title":"NormalizedDatabase"},{"location":"developer/assemble/data_structures/#platformidentifier","text":"platform_identify.py The PlatformIdentifier class attempts to identify the sequencing platform that was used to sequence the reads. This is accomplished by looking at the FASTQ file encoding and seeing if any of the information can be used to uniquely identify a sequencing platform. However, this process is not always successful and sometimes the platform will be determined to be \"Unidentifiable\".","title":"PlatformIdentifier"},{"location":"developer/assemble/data_structures/#readfilterer","text":"read_filterer.py Filters the reads using FASTP. The ReadFilterer object encapsulates information about the input reads and the several output files created by running FASTP.","title":"ReadFilterer"},{"location":"developer/assemble/data_structures/#readquality","text":"read_quality.py The ReadQuality object encapsulates information about the quality of reads. It includes measures such as the number of reads, the rate of Q30 or higher bases, and the GC-content.","title":"ReadQuality"},{"location":"developer/assemble/data_structures/#reads","text":"reads.py Encapsulates sequencing reads into a single object. This simplifies the need to pass forward and, optionally, reverse reads and accommodates a future possibility of having more than two read files.","title":"Reads"},{"location":"developer/assemble/data_structures/#species","text":"species.py Represents a biological species. The name attribute should exactly match the scientific name for the species (including capitalization). The confidence attribute relates to the confidence of the species assignment, which may be derived from species estimation tools, such as MASH.","title":"Species"},{"location":"developer/assemble/data_structures/#speciesestimation","text":"species_estimation.py Encapsulates a single \"estimation\" of a species. In particular, it is designed to encapsulate an estimation from Mash into a single object that can be passed and operated on more easily.","title":"SpeciesEstimation"},{"location":"developer/assemble/data_structures/#speciesestimator","text":"species_estimator.py The SpeciesEstimator represents a tool used to estimate species from either sequencing reads or contigs. It is not designed to be a species classifier, but rather simply estimate the species, based on the information on hand (in particular, the RefSeq Masher database).","title":"SpeciesEstimator"},{"location":"developer/evaluate/evaluate/","text":"Proksee Evaluate Overview v1.0.0-alpha 2021-04-08 The evaluate command is responsible for evaluating sequence assemblies by comparing their assembly metrics to our database of assembly metrics for the same species. The command essentially implements only the evaluate stages of the full proksee assemble command, and it may be useful to reference that documentation for more information. Pipeline The evaluate command consists of the following steps: estimate species measure assembly quality statistics heuristic evaluation machine learning evaluation Estimate Species The species of the provided contigs is estimated if it is not also provided by the user. This is done using using MASH. Since MASH is not designed to be a classifier, we shouldn't say that the species is classified, but rather the species is estimated from k-mer information. Since we are operating on contigs instead of reads, we would expect to have a multiplicity of the species k-mers at approximately 1. We cannot use a strict filtering criteria for species estimation as we do for proksee assemble . It is therefore more likely that contamination may be reported as the species. Measure Assembly Quality Statistics The assembly quality statistics are measured using QUAST. The pipeline uses a non-reference-based QUAST analysis, because of the difficulty of selecting a reference correctly and complication of needing to maintain either a database of references or the ability to download references on the fly. Several assembly metrics are collected, including N50, number of contigs, L50, and total assembly size. Heuristic Evaluation A heuristic evaluation is performed by comparing the assembly quality measurements to a previously-built database of assembly statistics for various species. This database simply contains threshold levels, determined from percentiles of the original assembly statistics. The evaluation compares the calculated statistics against these thresholds and reports the results. For example, if most Listeria monocytogenes have an N50 between 2,500,000 and 3,500,000, but our Listeria monocytogenes assembly has an N50 of 2,000,000, then we would report to the user that there is a problem with the N50. Machine Learning Evaluation A machine learning evaluation is performed by inputting the assembly statistics into a machine learning model. This model has been previously generated using the same data described in the heuristic evaluation. However, its methods are not the same. Please refer to the machine learning documentation under Evaluate Assembly for more information","title":"Evaluate"},{"location":"developer/evaluate/evaluate/#proksee-evaluate-overview","text":"v1.0.0-alpha 2021-04-08 The evaluate command is responsible for evaluating sequence assemblies by comparing their assembly metrics to our database of assembly metrics for the same species. The command essentially implements only the evaluate stages of the full proksee assemble command, and it may be useful to reference that documentation for more information.","title":"Proksee Evaluate Overview"},{"location":"developer/evaluate/evaluate/#pipeline","text":"The evaluate command consists of the following steps: estimate species measure assembly quality statistics heuristic evaluation machine learning evaluation","title":"Pipeline"},{"location":"developer/evaluate/evaluate/#estimate-species","text":"The species of the provided contigs is estimated if it is not also provided by the user. This is done using using MASH. Since MASH is not designed to be a classifier, we shouldn't say that the species is classified, but rather the species is estimated from k-mer information. Since we are operating on contigs instead of reads, we would expect to have a multiplicity of the species k-mers at approximately 1. We cannot use a strict filtering criteria for species estimation as we do for proksee assemble . It is therefore more likely that contamination may be reported as the species.","title":"Estimate Species"},{"location":"developer/evaluate/evaluate/#measure-assembly-quality-statistics","text":"The assembly quality statistics are measured using QUAST. The pipeline uses a non-reference-based QUAST analysis, because of the difficulty of selecting a reference correctly and complication of needing to maintain either a database of references or the ability to download references on the fly. Several assembly metrics are collected, including N50, number of contigs, L50, and total assembly size.","title":"Measure Assembly Quality Statistics"},{"location":"developer/evaluate/evaluate/#heuristic-evaluation","text":"A heuristic evaluation is performed by comparing the assembly quality measurements to a previously-built database of assembly statistics for various species. This database simply contains threshold levels, determined from percentiles of the original assembly statistics. The evaluation compares the calculated statistics against these thresholds and reports the results. For example, if most Listeria monocytogenes have an N50 between 2,500,000 and 3,500,000, but our Listeria monocytogenes assembly has an N50 of 2,000,000, then we would report to the user that there is a problem with the N50.","title":"Heuristic Evaluation"},{"location":"developer/evaluate/evaluate/#machine-learning-evaluation","text":"A machine learning evaluation is performed by inputting the assembly statistics into a machine learning model. This model has been previously generated using the same data described in the heuristic evaluation. However, its methods are not the same. Please refer to the machine learning documentation under Evaluate Assembly for more information","title":"Machine Learning Evaluation"},{"location":"tools/assemble/","text":"Assemble The assemble pipeline assembles sequencing reads using an expert system to guide decision-making through the various stages of sequence assembly. The pipeline consists of pre-assembly, fast assembly, and expert assembly stages. Stage 1: Pre-Assembly As part of pre-assembly, the pipeline will validate inputs, attempt to identify the sequencing platform, filter reads, determine read quality, and estimate the species. If the inputs appear to be invalid (ex: incorrect sequence encoding), then the pipeline will terminate early. Stage 2: Fast Assembly Fast assembly involves quickly assembling the reads in an approximate way to obtain information that will assist expert assembly. Fast assembly involves using the expert system to create an assembly strategy, assembling the reads with that strategy, evaluating the assembled contigs for contamination, and evaluating the fast assembly. The pipeline may terminate assembly during assembly strategy creation if there are multiple major species estimated in the reads. Similarly, when evaluating the assembled contigs for contamination, if any large contigs disagree with the previously estimated species, the pipeline will terminate. Stage 3: Expert Assembly Expert assembly leverages the information obtained in the pre-assembly and fast assembly stages to produce a higher-quality assembly. This stage involves using the expert system to create an assembly strategy, assembling the reads, evaluating the assembly, and finally generating a report by comparing the expert assembly to the fast assembly. The pipeline may terminate assembly during the creation of the assembly strategy if the assembly statistics (N50, L50, etc.) for the fast assembly appear to deviate from what is expected for the assembled species. This deviation is currently defined as outside a 5th to 95th percentile range of RefSeq-included assemblies for that species. Basic Usage Command Line proksee assemble [options] <forward reads> (<reverse reads>) Example proksee assemble -o output forward_reads.fastq reverse_reads.fastq Arguments Forward Reads The FASTQ-formatted short-length forward reads to assemble. These reads may either be unpaired reads or the forward reads of paired-end reads. Reverse Reads The FASTQ-formatted short-length reverse reads to assemble. This argument is optional and only provided as the matching pair to the forward reads provided in the previous argument. Options -o , --output The directory location to write output files. If this directory does not exist, then it will be created. Any files in this directory with the same name as any program output files will be overwritten. Force --force This flag forces the pipeline to continue when the pipeline would otherwise terminate. For example, it will force the pipeline to continue assembly even if it appears there is considerable contamination or the fast assembly statistics look erroneous. Species -s , --species This option allows the user to specify the species in the reads to be assembled. The name must exactly match the scientific name for the species (ex: --species 'Listeria monocytogenes' ). This will override any species estimation. If the passed species name does not match any species in the database, an error message will be displayed and the species will attempt to be estimated as normal. Platform -p , --platform The option allows the user to specify the sequencing platform that generated the reads. The name must be either: 'Illumina', 'Pac Bio', or 'Ion Torrent'. For example: --platform 'Ion Torrent' . If the passed platform name does not match a known platform, then the pipeline will attempt to identify the platform from the reads as normal. Help --help Shows a help message and exits. Output All output will be written to the specified output directory or, if unspecified, the current directory. The output directory will contain the following files: assembly_statistics.csv : assembly statistics for the assemblies produced during pipeline contigs.fasta : the final contigs generated from the expert assembly assembly_info.json : a computer-readable, JSON-formatted file containing the information that was printed to standard output The output directory may also contain output from various other programs called during execution of the pipeline.","title":"Assemble"},{"location":"tools/assemble/#assemble","text":"The assemble pipeline assembles sequencing reads using an expert system to guide decision-making through the various stages of sequence assembly. The pipeline consists of pre-assembly, fast assembly, and expert assembly stages.","title":"Assemble"},{"location":"tools/assemble/#stage-1-pre-assembly","text":"As part of pre-assembly, the pipeline will validate inputs, attempt to identify the sequencing platform, filter reads, determine read quality, and estimate the species. If the inputs appear to be invalid (ex: incorrect sequence encoding), then the pipeline will terminate early.","title":"Stage 1: Pre-Assembly"},{"location":"tools/assemble/#stage-2-fast-assembly","text":"Fast assembly involves quickly assembling the reads in an approximate way to obtain information that will assist expert assembly. Fast assembly involves using the expert system to create an assembly strategy, assembling the reads with that strategy, evaluating the assembled contigs for contamination, and evaluating the fast assembly. The pipeline may terminate assembly during assembly strategy creation if there are multiple major species estimated in the reads. Similarly, when evaluating the assembled contigs for contamination, if any large contigs disagree with the previously estimated species, the pipeline will terminate.","title":"Stage 2: Fast Assembly"},{"location":"tools/assemble/#stage-3-expert-assembly","text":"Expert assembly leverages the information obtained in the pre-assembly and fast assembly stages to produce a higher-quality assembly. This stage involves using the expert system to create an assembly strategy, assembling the reads, evaluating the assembly, and finally generating a report by comparing the expert assembly to the fast assembly. The pipeline may terminate assembly during the creation of the assembly strategy if the assembly statistics (N50, L50, etc.) for the fast assembly appear to deviate from what is expected for the assembled species. This deviation is currently defined as outside a 5th to 95th percentile range of RefSeq-included assemblies for that species.","title":"Stage 3: Expert Assembly"},{"location":"tools/assemble/#basic-usage","text":"Command Line proksee assemble [options] <forward reads> (<reverse reads>) Example proksee assemble -o output forward_reads.fastq reverse_reads.fastq","title":"Basic Usage"},{"location":"tools/assemble/#arguments","text":"","title":"Arguments"},{"location":"tools/assemble/#forward-reads","text":"The FASTQ-formatted short-length forward reads to assemble. These reads may either be unpaired reads or the forward reads of paired-end reads.","title":"Forward Reads"},{"location":"tools/assemble/#reverse-reads","text":"The FASTQ-formatted short-length reverse reads to assemble. This argument is optional and only provided as the matching pair to the forward reads provided in the previous argument.","title":"Reverse Reads"},{"location":"tools/assemble/#options","text":"-o , --output The directory location to write output files. If this directory does not exist, then it will be created. Any files in this directory with the same name as any program output files will be overwritten.","title":"Options"},{"location":"tools/assemble/#force","text":"--force This flag forces the pipeline to continue when the pipeline would otherwise terminate. For example, it will force the pipeline to continue assembly even if it appears there is considerable contamination or the fast assembly statistics look erroneous.","title":"Force"},{"location":"tools/assemble/#species","text":"-s , --species This option allows the user to specify the species in the reads to be assembled. The name must exactly match the scientific name for the species (ex: --species 'Listeria monocytogenes' ). This will override any species estimation. If the passed species name does not match any species in the database, an error message will be displayed and the species will attempt to be estimated as normal.","title":"Species"},{"location":"tools/assemble/#platform","text":"-p , --platform The option allows the user to specify the sequencing platform that generated the reads. The name must be either: 'Illumina', 'Pac Bio', or 'Ion Torrent'. For example: --platform 'Ion Torrent' . If the passed platform name does not match a known platform, then the pipeline will attempt to identify the platform from the reads as normal.","title":"Platform"},{"location":"tools/assemble/#help","text":"--help Shows a help message and exits.","title":"Help"},{"location":"tools/assemble/#output","text":"All output will be written to the specified output directory or, if unspecified, the current directory. The output directory will contain the following files: assembly_statistics.csv : assembly statistics for the assemblies produced during pipeline contigs.fasta : the final contigs generated from the expert assembly assembly_info.json : a computer-readable, JSON-formatted file containing the information that was printed to standard output The output directory may also contain output from various other programs called during execution of the pipeline.","title":"Output"},{"location":"tools/evaluate/","text":"Evaluate The evaluate command evaluates the quality of sequence assemblies by comparing their various sequence assembly metrics to previous assemblies available in our database of the same species. It provides a report estimating the quality of the provided assembly. This command essentially performs only the evaluation part of proksee assemble and therefore allows users to evaluate assemblies directly. Warning Proksee evaluate is designed to evaluate draft sequence assemblies and not complete genomes. The sort of assemblies that should be evaluated are those generated directly by sequence assembly tools. As complete genomes usually have very different assembly metrics (N50, number of contigs, etc.) from typical draft assemblies, it is difficult to evaluate a complete genome as a draft assembly. Basic Usage Command Line proksee evaluate [options] <contigs> Example proksee evaluate -o output contigs.fasta Arguments Contigs The FASTA-formatted contigs representing a sequence assembly. Options -o , --output The directory location to write output files. If this directory does not exist, then it will be created. Any files in this directory with the same name as any program output files will be overwritten. Species -s , --species This option allows the user to specify the species of the assembly. The name must exactly match the scientific name for the species (ex: --species 'Listeria monocytogenes' ). This will override any species estimation. If the passed species name does not match any species in the database, an error message will be displayed and the species will attempt to be estimated as normal. Help --help Shows a help message and exits. Output All output will be written to the specified output directory. The output directory will contain the following files: assembly_statistics.csv : assembly statistics for the provided assembly The output directory may also contain output from various other programs called during execution of the pipeline.","title":"Evaluate"},{"location":"tools/evaluate/#evaluate","text":"The evaluate command evaluates the quality of sequence assemblies by comparing their various sequence assembly metrics to previous assemblies available in our database of the same species. It provides a report estimating the quality of the provided assembly. This command essentially performs only the evaluation part of proksee assemble and therefore allows users to evaluate assemblies directly. Warning Proksee evaluate is designed to evaluate draft sequence assemblies and not complete genomes. The sort of assemblies that should be evaluated are those generated directly by sequence assembly tools. As complete genomes usually have very different assembly metrics (N50, number of contigs, etc.) from typical draft assemblies, it is difficult to evaluate a complete genome as a draft assembly.","title":"Evaluate"},{"location":"tools/evaluate/#basic-usage","text":"Command Line proksee evaluate [options] <contigs> Example proksee evaluate -o output contigs.fasta","title":"Basic Usage"},{"location":"tools/evaluate/#arguments","text":"","title":"Arguments"},{"location":"tools/evaluate/#contigs","text":"The FASTA-formatted contigs representing a sequence assembly.","title":"Contigs"},{"location":"tools/evaluate/#options","text":"-o , --output The directory location to write output files. If this directory does not exist, then it will be created. Any files in this directory with the same name as any program output files will be overwritten.","title":"Options"},{"location":"tools/evaluate/#species","text":"-s , --species This option allows the user to specify the species of the assembly. The name must exactly match the scientific name for the species (ex: --species 'Listeria monocytogenes' ). This will override any species estimation. If the passed species name does not match any species in the database, an error message will be displayed and the species will attempt to be estimated as normal.","title":"Species"},{"location":"tools/evaluate/#help","text":"--help Shows a help message and exits.","title":"Help"},{"location":"tools/evaluate/#output","text":"All output will be written to the specified output directory. The output directory will contain the following files: assembly_statistics.csv : assembly statistics for the provided assembly The output directory may also contain output from various other programs called during execution of the pipeline.","title":"Output"},{"location":"tutorials/assemble/","text":"Assemble Tutorial The following is a set of simple tutorials to illustrate how to run Proksee Assemble on a Linux command line and how to understand the outputs. Please ensure that you have already installed Proksee according the installation instructions . Data You will first need to obtain sequencing data to assemble. For this tutorial, we will be using Vibrio cholerae reads generated from an Illumina sequencing machine using a whole-genome sequencing strategy. The reads can be downloaded either by using NCBI's SRA Toolkit or downloading the reads directly from a web browser. Option 1: SRA Toolkit Download You will need to follow NCBI's instructions on how to install and use the SRA Toolkit. We will download sequencing run SRR9201324 and, for the sake of simplicity, concatinate the pair-end reads into a single file. fasterq-dump SRR9201324 cat SRR9201324_1.fastq SRR9201324_2.fastq > SRR9201324.fastq The output file should be named \"SRR9201324.fastq\". Option 2: Web Browser Download You can download the reads directly from this link . You will then need to extract and possibly rename the files: gzip -d sra_data.fastq.qz mv sra_data.fastq SRR9201324.fastq Setup Activate the Proksee conda environment: conda activate proksee Check that Proksee can be run: proksee assemble --help If Proksee is installed correctly and the Conda environment activated correctly, you should see a help message reported: Usage: proksee assemble [OPTIONS] FORWARD [REVERSE] Options: -o, --output DIRECTORY [required] --force This will force the assembler to proceed when the assembly appears to be poor. -s, --species TEXT The species to assemble. This will override species estimation. Must be spelled correctly. -p, --platform TEXT The sequencing platform used to generate the reads. 'Illumina', 'Ion Torrent', or 'Pac Bio'. --help Show this message and exit. If you see this output, then it is likely that Proksee is installed correctly and ready to be run. Running Proksee You can assemble the reads we downloaded earlier with the following command: proksee assemble SRR9201324.fastq -o output/ This will initiate an assembly of the SRR9201324 Vibrio cholerae reads and place all outputs in a directory called \"output\". Standard Output After running Proksee Assemble, output will be written to standard output and to the output directory. If you wish to see the full output, please expand the collapsed section below. The output will be explained part by part further below. Full Output The reads appear to be formatted correctly. Attempting to identify the sequencing platform from the reads. Sequencing Platform: Unidentifiable Attempting to identify the species from the input. SPECIES: Vibrio cholerae (p=1.00) WARNING: Additional high-confidence species were found in the input data: Vibrio albensis (p=1.00) Atlantibacter hermannii (p=1.00) Klebsiella michiganensis (p=1.00) Erwinia amylovora (p=1.00) The read quality is acceptable. Assembled reads using Skesa. PASS: The evaluated contigs appear to agree with the species estimation. The estimated species is: Vibrio cholerae (p=1.00) Evaluated the quality of the assembled contigs. The probability of the assembly being a good assembly is: 0.58. WARNING: The N50 is somewhat smaller than expected: 88901 The N50 lower bound is: 47306.5 PASS: The number of contigs is comparable to similar assemblies: 104 The acceptable number of contigs range is: (50.1, 265.9) WARNING: The L50 is somewhat larger than expected: 15 The L50 upper bound is: 26.9 WARNING: The assembly length is somewhat smaller than expected: 3939096 The assembly length lower bound is: 3884870.0 Performing expert assembly. Assembled reads using SPAdes. Evaluated the quality of the assembled contigs. The probability of the assembly being a good assembly is: 0.89. PASS: The N50 is comparable to similar assemblies: 108383 The acceptable N50 range is: (47306.5, 375823.9) PASS: The number of contigs is comparable to similar assemblies: 89 The acceptable number of contigs range is: (50.1, 265.9) PASS: The L50 is comparable to similar assemblies: 12 The acceptable L50 range is: (4.0, 26.9) PASS: The assembly length is comparable to similar assemblies: 3970349 The acceptable assembly length range is: (3884870.0, 4184063.4) Changes in assembly statistics: N50: 19482 Number of Contigs: -15 L50: -3 Length: 31253 Complete. Read Formatting The reads appear to be formatted correctly. Proksee quickly checks to see if the reads appear to be correctly formatted. In our example, the reads appear to be formatted correctly. Sequencing Platform Identification Attempting to identify the sequencing platform from the reads. Sequencing Platform: Unidentifiable The software attempts to estimate the sequencing platform. However, as above, it is not always to uniquely identify the sequencing platform based on the FASTQ encoding and the platform is reported as \"Unknown\". Species Estimation Attempting to identify the species from the input. SPECIES: Vibrio cholerae (p=1.00) WARNING: Additional high-confidence species were found in the input data: Vibrio albensis (p=1.00) Atlantibacter hermannii (p=1.00) Klebsiella michiganensis (p=1.00) Erwinia amylovora (p=1.00) The species is estimated using Mash and the species with the most evidence is selected. There may be additional high-confidence species reported. In this case, the species selected is Vibrio cholerae , but there are several other estimations ( Vibrio albensis , Atlantibacter hermannii , etc.) with high confidence. As species estimation is somewhat inexact and complicated, we do not immediately flag the reads as being problematic, but instead verify the species again after contigs are assembled. Read Quality Check The read quality is acceptable. The quality of the reads is evaluated using FASTP. If the quality is acceptable, then assembly will continue. In our example, the read quality appears to be acceptable. Fast Sequence Assembly Assembled reads using Skesa. The reads are quickly assembled using Skesa. Species Verification PASS: The evaluated contigs appear to agree with the species estimation. The estimated species is: Vibrio cholerae (p=1.00) A few of the largest contigs of the assembly each have their species estimated with RefSeq Masher. If the species estimated from each of these contigs is in agreement with the species estimated previously, then the assembly continues. It is possible that some data sets with contamination will continue in the pipeline, but as confident and automatic species estimation prove challenging, it is difficult to automate processes to handle low levels of contamination. In the example above, since we previously estimated the species from the reads to be Vibrio cholerae and this agrees with the species estimated from each of the largest contigs (individually), then we proceed with sequence assembly. Machine Learning Assembly Evaluation Evaluated the quality of the assembled contigs. The probability of the assembly being a good assembly is: 0.58. The probability of the sequence assembly being \"good\" is estimating using our machine learning algorithm. Here we see that the probability of the assembly being \"good\" (i.e. similar to other RefSeq assemblies that we believe are good) is 58%. Heuristic Assembly Evaluation WARNING: The N50 is somewhat smaller than expected: 88901 The N50 lower bound is: 47306.5 PASS: The number of contigs is comparable to similar assemblies: 104 The acceptable number of contigs range is: (50.1, 265.9) WARNING: The L50 is somewhat larger than expected: 15 The L50 upper bound is: 26.9 WARNING: The assembly length is somewhat smaller than expected: 3939096 The assembly length lower bound is: 3884870.0 The sequence assembly is the evaluated using a heuristic-based approach. The N50, number of contigs, L50, and assembly length are compared against the range of values for assemblies of that species and sequencing technology in our database of assemblies. The software reports a warning when the assembly measurement (N50, L50, etc.) is outside the 20-80 percentile range, and a failure when the measurement is outside the 5-95 percentile range. In this case, we see that the number of contigs (104) seems comparable, but the N50 (88901), L50 (15), and assembly length (3,939,096) deviate somewhat from what is expect. However, their deviation is not too extreme, so warnings are issued and the assembly continues. Expert Assembly Performing expert assembly. Assembled reads using SPAdes. Using information collected in the previous steps, a strategy is determined for the \"expert\" assembly. The hope is that we can use information gathered from a fast Skesa assembly to better inform a more thorough assembly. In this case, SPAdes was selected to assembly the reads. Machine Learning Assembly Evaluation Evaluated the quality of the assembled contigs. The probability of the assembly being a good assembly is: 0.89. Proksee now evaluates the probability of the expert assembly being a good assembly (i.e. similar to assemblies in our RefSeq-derived assembly database) and reports that probability. There is an 89% probability that our expert assembly is similar to our RefSeq-derived assembly database. Heuristic Assembly Evaluation PASS: The N50 is comparable to similar assemblies: 108383 The acceptable N50 range is: (47306.5, 375823.9) PASS: The number of contigs is comparable to similar assemblies: 89 The acceptable number of contigs range is: (50.1, 265.9) PASS: The L50 is comparable to similar assemblies: 12 The acceptable L50 range is: (4.0, 26.9) PASS: The assembly length is comparable to similar assemblies: 3970349 The acceptable assembly length range is: (3884870.0, 4184063.4) The expert assembly is then evaluated using our heuristic approach, by comparing the assembly measurements against the percentile ranges for assemblies of the same species and sequencing techonology in our database. In our example, all of the assemble measurements derived from the expert assembly appear normal, with respect to our database. Changes in Assemblies Changes in assembly statistics: N50: 19482 Number of Contigs: -15 L50: -3 Length: 31253 Complete. Finally, the changes in assembly measurements (N50, L50, etc.) between the fast assembly and the expert assembly are reported. In this case, we can see changes that suggest an improvement in assembly quality. Output Files All output will be written to the specified output directory (\"output\" in our case). The output directory will contain the following files: assembly_statistics.csv : assembly statistics for the assemblies produced during pipeline contigs.fasta : the final contigs generated from the expert assembly assembly_info.json : a computer-readable, JSON-formatted file containing the information that was printed to standard output The output directory may also contain output from various other programs called during execution of the pipeline, such as Quast and fastp.","title":"Assemble"},{"location":"tutorials/assemble/#assemble-tutorial","text":"The following is a set of simple tutorials to illustrate how to run Proksee Assemble on a Linux command line and how to understand the outputs. Please ensure that you have already installed Proksee according the installation instructions .","title":"Assemble Tutorial"},{"location":"tutorials/assemble/#data","text":"You will first need to obtain sequencing data to assemble. For this tutorial, we will be using Vibrio cholerae reads generated from an Illumina sequencing machine using a whole-genome sequencing strategy. The reads can be downloaded either by using NCBI's SRA Toolkit or downloading the reads directly from a web browser. Option 1: SRA Toolkit Download You will need to follow NCBI's instructions on how to install and use the SRA Toolkit. We will download sequencing run SRR9201324 and, for the sake of simplicity, concatinate the pair-end reads into a single file. fasterq-dump SRR9201324 cat SRR9201324_1.fastq SRR9201324_2.fastq > SRR9201324.fastq The output file should be named \"SRR9201324.fastq\". Option 2: Web Browser Download You can download the reads directly from this link . You will then need to extract and possibly rename the files: gzip -d sra_data.fastq.qz mv sra_data.fastq SRR9201324.fastq","title":"Data"},{"location":"tutorials/assemble/#setup","text":"Activate the Proksee conda environment: conda activate proksee Check that Proksee can be run: proksee assemble --help If Proksee is installed correctly and the Conda environment activated correctly, you should see a help message reported: Usage: proksee assemble [OPTIONS] FORWARD [REVERSE] Options: -o, --output DIRECTORY [required] --force This will force the assembler to proceed when the assembly appears to be poor. -s, --species TEXT The species to assemble. This will override species estimation. Must be spelled correctly. -p, --platform TEXT The sequencing platform used to generate the reads. 'Illumina', 'Ion Torrent', or 'Pac Bio'. --help Show this message and exit. If you see this output, then it is likely that Proksee is installed correctly and ready to be run.","title":"Setup"},{"location":"tutorials/assemble/#running-proksee","text":"You can assemble the reads we downloaded earlier with the following command: proksee assemble SRR9201324.fastq -o output/ This will initiate an assembly of the SRR9201324 Vibrio cholerae reads and place all outputs in a directory called \"output\".","title":"Running Proksee"},{"location":"tutorials/assemble/#standard-output","text":"After running Proksee Assemble, output will be written to standard output and to the output directory. If you wish to see the full output, please expand the collapsed section below. The output will be explained part by part further below. Full Output The reads appear to be formatted correctly. Attempting to identify the sequencing platform from the reads. Sequencing Platform: Unidentifiable Attempting to identify the species from the input. SPECIES: Vibrio cholerae (p=1.00) WARNING: Additional high-confidence species were found in the input data: Vibrio albensis (p=1.00) Atlantibacter hermannii (p=1.00) Klebsiella michiganensis (p=1.00) Erwinia amylovora (p=1.00) The read quality is acceptable. Assembled reads using Skesa. PASS: The evaluated contigs appear to agree with the species estimation. The estimated species is: Vibrio cholerae (p=1.00) Evaluated the quality of the assembled contigs. The probability of the assembly being a good assembly is: 0.58. WARNING: The N50 is somewhat smaller than expected: 88901 The N50 lower bound is: 47306.5 PASS: The number of contigs is comparable to similar assemblies: 104 The acceptable number of contigs range is: (50.1, 265.9) WARNING: The L50 is somewhat larger than expected: 15 The L50 upper bound is: 26.9 WARNING: The assembly length is somewhat smaller than expected: 3939096 The assembly length lower bound is: 3884870.0 Performing expert assembly. Assembled reads using SPAdes. Evaluated the quality of the assembled contigs. The probability of the assembly being a good assembly is: 0.89. PASS: The N50 is comparable to similar assemblies: 108383 The acceptable N50 range is: (47306.5, 375823.9) PASS: The number of contigs is comparable to similar assemblies: 89 The acceptable number of contigs range is: (50.1, 265.9) PASS: The L50 is comparable to similar assemblies: 12 The acceptable L50 range is: (4.0, 26.9) PASS: The assembly length is comparable to similar assemblies: 3970349 The acceptable assembly length range is: (3884870.0, 4184063.4) Changes in assembly statistics: N50: 19482 Number of Contigs: -15 L50: -3 Length: 31253 Complete. Read Formatting The reads appear to be formatted correctly. Proksee quickly checks to see if the reads appear to be correctly formatted. In our example, the reads appear to be formatted correctly. Sequencing Platform Identification Attempting to identify the sequencing platform from the reads. Sequencing Platform: Unidentifiable The software attempts to estimate the sequencing platform. However, as above, it is not always to uniquely identify the sequencing platform based on the FASTQ encoding and the platform is reported as \"Unknown\". Species Estimation Attempting to identify the species from the input. SPECIES: Vibrio cholerae (p=1.00) WARNING: Additional high-confidence species were found in the input data: Vibrio albensis (p=1.00) Atlantibacter hermannii (p=1.00) Klebsiella michiganensis (p=1.00) Erwinia amylovora (p=1.00) The species is estimated using Mash and the species with the most evidence is selected. There may be additional high-confidence species reported. In this case, the species selected is Vibrio cholerae , but there are several other estimations ( Vibrio albensis , Atlantibacter hermannii , etc.) with high confidence. As species estimation is somewhat inexact and complicated, we do not immediately flag the reads as being problematic, but instead verify the species again after contigs are assembled. Read Quality Check The read quality is acceptable. The quality of the reads is evaluated using FASTP. If the quality is acceptable, then assembly will continue. In our example, the read quality appears to be acceptable. Fast Sequence Assembly Assembled reads using Skesa. The reads are quickly assembled using Skesa. Species Verification PASS: The evaluated contigs appear to agree with the species estimation. The estimated species is: Vibrio cholerae (p=1.00) A few of the largest contigs of the assembly each have their species estimated with RefSeq Masher. If the species estimated from each of these contigs is in agreement with the species estimated previously, then the assembly continues. It is possible that some data sets with contamination will continue in the pipeline, but as confident and automatic species estimation prove challenging, it is difficult to automate processes to handle low levels of contamination. In the example above, since we previously estimated the species from the reads to be Vibrio cholerae and this agrees with the species estimated from each of the largest contigs (individually), then we proceed with sequence assembly. Machine Learning Assembly Evaluation Evaluated the quality of the assembled contigs. The probability of the assembly being a good assembly is: 0.58. The probability of the sequence assembly being \"good\" is estimating using our machine learning algorithm. Here we see that the probability of the assembly being \"good\" (i.e. similar to other RefSeq assemblies that we believe are good) is 58%. Heuristic Assembly Evaluation WARNING: The N50 is somewhat smaller than expected: 88901 The N50 lower bound is: 47306.5 PASS: The number of contigs is comparable to similar assemblies: 104 The acceptable number of contigs range is: (50.1, 265.9) WARNING: The L50 is somewhat larger than expected: 15 The L50 upper bound is: 26.9 WARNING: The assembly length is somewhat smaller than expected: 3939096 The assembly length lower bound is: 3884870.0 The sequence assembly is the evaluated using a heuristic-based approach. The N50, number of contigs, L50, and assembly length are compared against the range of values for assemblies of that species and sequencing technology in our database of assemblies. The software reports a warning when the assembly measurement (N50, L50, etc.) is outside the 20-80 percentile range, and a failure when the measurement is outside the 5-95 percentile range. In this case, we see that the number of contigs (104) seems comparable, but the N50 (88901), L50 (15), and assembly length (3,939,096) deviate somewhat from what is expect. However, their deviation is not too extreme, so warnings are issued and the assembly continues. Expert Assembly Performing expert assembly. Assembled reads using SPAdes. Using information collected in the previous steps, a strategy is determined for the \"expert\" assembly. The hope is that we can use information gathered from a fast Skesa assembly to better inform a more thorough assembly. In this case, SPAdes was selected to assembly the reads. Machine Learning Assembly Evaluation Evaluated the quality of the assembled contigs. The probability of the assembly being a good assembly is: 0.89. Proksee now evaluates the probability of the expert assembly being a good assembly (i.e. similar to assemblies in our RefSeq-derived assembly database) and reports that probability. There is an 89% probability that our expert assembly is similar to our RefSeq-derived assembly database. Heuristic Assembly Evaluation PASS: The N50 is comparable to similar assemblies: 108383 The acceptable N50 range is: (47306.5, 375823.9) PASS: The number of contigs is comparable to similar assemblies: 89 The acceptable number of contigs range is: (50.1, 265.9) PASS: The L50 is comparable to similar assemblies: 12 The acceptable L50 range is: (4.0, 26.9) PASS: The assembly length is comparable to similar assemblies: 3970349 The acceptable assembly length range is: (3884870.0, 4184063.4) The expert assembly is then evaluated using our heuristic approach, by comparing the assembly measurements against the percentile ranges for assemblies of the same species and sequencing techonology in our database. In our example, all of the assemble measurements derived from the expert assembly appear normal, with respect to our database. Changes in Assemblies Changes in assembly statistics: N50: 19482 Number of Contigs: -15 L50: -3 Length: 31253 Complete. Finally, the changes in assembly measurements (N50, L50, etc.) between the fast assembly and the expert assembly are reported. In this case, we can see changes that suggest an improvement in assembly quality.","title":"Standard Output"},{"location":"tutorials/assemble/#output-files","text":"All output will be written to the specified output directory (\"output\" in our case). The output directory will contain the following files: assembly_statistics.csv : assembly statistics for the assemblies produced during pipeline contigs.fasta : the final contigs generated from the expert assembly assembly_info.json : a computer-readable, JSON-formatted file containing the information that was printed to standard output The output directory may also contain output from various other programs called during execution of the pipeline, such as Quast and fastp.","title":"Output Files"}]}